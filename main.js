(() => {\n  'use strict';\n  const clamp = (v,min,max)=>Math.max(min,Math.min(max,v));\n  const rand = (a,b)=>Math.random()*(b-a)+a;\n  const now = ()=>performance.now();\n\n  const Audio = (()=>{ let ctx=null, enabled=true; const ensure=()=>{ if(!ctx){ try{ ctx=new (window.AudioContext||window.webkitAudioContext)(); }catch(e){} } return ctx; }; const toggle=()=>{ enabled=!enabled; return enabled; }; const resume=()=>{ if(ctx && ctx.state==='suspended') ctx.resume(); }; const beep=(freq=440, dur=0.08, type='sine', vol=0.1)=>{ if(!enabled) return; const c=ensure(); if(!c) return; const o=c.createOscillator(); const g=c.createGain(); o.type=type; o.frequency.value=freq; g.gain.value=vol; o.connect(g).connect(c.destination); const t=c.currentTime; o.start(t); o.stop(t+dur); g.gain.exponentialRampToValueAtTime(0.0001, t+dur); }; return { ensure, toggle, resume, beep, get enabled(){ return enabled; } }; })();\n\n  const Storage = {\n    getName(){ return (localStorage.getItem('player_name')||'').trim(); },\n    setName(n){ localStorage.setItem('player_name', n); },\n    getBest(){ return Number(localStorage.getItem('best')||0); },\n    setBest(v){ localStorage.setItem('best', String(v|0)); },\n    getBoard(){ try { return JSON.parse(localStorage.getItem('leaderboard')||'[]'); } catch { return []; } },\n    setBoard(arr){ localStorage.setItem('leaderboard', JSON.stringify(arr)); }\n  };\n\n  const SUPABASE_URL = 'https://jiubirptbmvrsazbeegp.supabase.co';\n  const SUPABASE_ANON_KEY = 'sb_publishable_umWrXM7Ife75i5E0HRo-gQ_E-DjGg9O';\n  const sb = (window.supabase && SUPABASE_URL && SUPABASE_ANON_KEY)\n    ? window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY, { auth: { persistSession: false } })\n    : null;\n\n  async function fetchGlobalTop10(){\n    if(!sb) return [];\n    try {\n      const { data, error } = await sb.from('scores')\n        .select('name,score,created_at')\n        .order('score', { ascending: false })\n        .order('created_at', { ascending: true })\n        .limit(10);\n      if(error) throw error;\n      return Array.isArray(data) ? data : [];\n    } catch(e){\n      console.warn('[GlobalBoard] primary query failed, fallback without created_at', e?.message||e);\n      try {\n        const { data, error } = await sb.from('scores')\n          .select('name,score')\n          .order('score', { ascending: false })\n          .limit(10);\n        if(error) throw error;\n        return Array.isArray(data) ? data : [];\n      } catch (e2) {\n        console.error('[GlobalBoard] fallback query failed', e2?.message||e2);\n        return [];\n      }\n    }\n  }\n\n  async function submitGlobalScore(name, score){\n    if(!sb) return { ok:false };\n    const n = sanitizeName(name)||'Player';\n    const s = Math.max(0, score|0);\n    try {\n      const { error } = await sb.from('scores').insert({ name: n, score: s });\n      if(error) throw error;\n      return { ok:true };\n    } catch(e){\n      console.error('[GlobalSubmit] failed', e);\n      return { ok:false, error:e };\n    }\n  }\n\n  const NAME_MAX = 12;\n  const sanitizeName = (s)=>{\n    return (s||'').toString().replace(/\\s+/g,' ').trim().slice(0, NAME_MAX);\n  };\n\n  function submitScore(name, score){\n    const n = sanitizeName(name)||'Player';\n    const entry = { name: n, score: score|0, t: Date.now() };\n    const board = Storage.getBoard();\n    board.push(entry);\n    board.sort((a,b)=> b.score - a.score || a.t - b.t);\n    const TOP = 10;\n    const trimmed = board.slice(0, TOP);\n    Storage.setBoard(trimmed);\n    const rank = trimmed.findIndex(e => e === entry) + 1; // 1-based if remained in top\n    return { rank: rank>0?rank:null, board: trimmed };\n  }\n\n  function renderBoard(listEl, board){\n    if(!listEl) return;\n    listEl.innerHTML = '';\n    const frag = document.createDocumentFragment();\n    board.forEach((e,i)=>{\n      const li = document.createElement('li');\n      const name = (e.name||'Player').toString().replace(/</g,'&lt;');\n      const score = (e.score|0);\n      li.innerHTML = `<span class=\"pos\">${i+1}</span> <span class=\"nm\">${name}</span> <span class=\"sc\">${score}</span>`;\n      frag.appendChild(li);\n    });\n    listEl.appendChild(frag);\n  }\n\n  class Pool { constructor(create){ this.create=create; this.items=[]; } get(){ return this.items.pop()||this.create(); } put(o){ this.items.push(o); } }\n  class Entity { constructor(){ this.x=0; this.y=0; this.w=24; this.h=24; this.vx=0; this.vy=0; this.alive=false; } rect(){ return {x:this.x,y:this.y,w:this.w,h:this.h}; } }\n  class Poop extends Entity {\n    constructor(){ super(); this.kind='poop'; this.rot=0; this.speed=120; this.tone=0; }\n    spawn(x,y,speed){ this.x=x; this.y=y; this.speed=speed; this.vx=rand(-40,40); this.vy=this.speed; this.alive=true; this.w=this.h=rand(20,36); this.tone=rand(-0.06,0.08); }\n    step(dt){ this.vy += 220*dt*0.2; this.x += this.vx*dt; this.y += this.vy*dt; this.rot += this.vx*dt*0.02; }\n    draw(g){\n      const s = Math.max(this.w, this.h);\n      g.save();\n      const sq = clamp(this.vy/520, 0, 0.22);\n      g.translate(this.x+this.w/2, this.y+this.h/2);\n      g.rotate(this.rot);\n      g.scale(1+sq*0.08, 1-sq*0.12);\n      g.globalAlpha = 0.18; g.fillStyle = '#000'; g.beginPath(); g.ellipse(0, s*0.38, s*0.46, s*0.16, 0, 0, Math.PI*2); g.fill(); g.globalAlpha = 1;\n      const top = `hsl(${28+this.tone*30}, 55%, ${48+this.tone*10}%)`;\n      const mid = `hsl(${26+this.tone*30}, 58%, ${36+this.tone*6}%)`;\n      const bot = `hsl(${24+this.tone*30}, 62%, ${22+this.tone*4}%)`;\n      const grad = g.createLinearGradient(0, -s*0.45, 0, s*0.42);\n      grad.addColorStop(0, top); grad.addColorStop(0.5, mid); grad.addColorStop(1, bot);\n      g.fillStyle = grad;\n      const drawLayer = (cx, cy, rx, ry) => { g.beginPath(); g.ellipse(cx, cy, rx, ry, 0, 0, Math.PI*2); g.fill(); };\n      drawLayer(0, s*0.14, s*0.44, s*0.22);\n      drawLayer(0, -s*0.02, s*0.32, s*0.18);\n      drawLayer(0, -s*0.18, s*0.22, s*0.14);\n      g.beginPath(); g.arc(0, -s*0.30, s*0.10, 0, Math.PI*2); g.fill();\n      g.strokeStyle = 'rgba(0,0,0,0.22)'; g.lineWidth = Math.max(1, s*0.018);\n      const rim = (cx, cy, rx, ry)=>{ g.beginPath(); g.ellipse(cx, cy, rx, ry, 0, Math.PI*0.05, Math.PI*0.95); g.stroke(); };\n      rim(0, s*0.02, s*0.34, s*0.19); rim(0, -s*0.14, s*0.24, s*0.15);\n      g.globalAlpha = 0.22; g.fillStyle = '#fff'; g.beginPath(); g.ellipse(-s*0.10, -s*0.20, s*0.08, s*0.04, -0.6, 0, Math.PI*2); g.fill(); g.globalAlpha = 0.12; g.beginPath(); g.ellipse(-s*0.02, -s*0.05, s*0.12, s*0.06, -0.5, 0, Math.PI*2); g.fill(); g.globalAlpha = 1;\n      g.fillStyle = 'rgba(0,0,0,0.10)'; for(let i=0;i<3;i++){ const ax = rand(-s*0.18, s*0.18), ay = rand(-s*0.08, s*0.18); g.beginPath(); g.arc(ax, ay, s*0.012, 0, Math.PI*2); g.fill(); }\n      g.restore();\n    }\n  }\n\n  class PowerUp extends Entity { constructor(){ super(); this.kind='power'; this.type='shield'; } spawn(x,y,type){ this.x=x; this.y=y; this.type=type; this.vx=0; this.vy=90; this.alive=true; this.w=this.h=20; } step(dt){ this.y += this.vy*dt; } draw(g){ g.save(); g.translate(this.x+this.w/2, this.y+this.h/2); if(this.type==='shield'){ g.strokeStyle='#22c55e'; g.lineWidth=3; g.beginPath(); g.arc(0,0,this.w/2,0,Math.PI*2); g.stroke(); } else { g.fillStyle='#38bdf8'; g.fillRect(-this.w/2,-this.h/2,this.w,this.h); } g.restore(); } }\n  class Player extends Entity { constructor(){ super(); this.w=34; this.h=18; this.speed=240; this.shield=0; } draw(g){ g.fillStyle=this.shield>0?'#22c55e':'#e5e7eb'; g.fillRect(this.x, this.y, this.w, this.h); if(this.shield>0){ g.strokeStyle='#22c55e'; g.lineWidth=2; g.strokeRect(this.x-4,this.y-4,this.w+8,this.h+8); } } }\n  const hit=(a,b)=>!(a.x+a.w<b.x||b.x+b.w<a.x||a.y+a.h<b.y||b.y+b.h<a.y);\n\n  class Game{\n    constructor(canvas){\n      this.c=canvas; this.g=canvas.getContext('2d'); this.w=canvas.width; this.h=canvas.height;\n      this.player=new Player(); this.player.x=this.w/2-17; this.player.y=this.h-56;\n      this.poopPool=new Pool(()=>new Poop()); this.powerPool=new Pool(()=>new PowerUp());\n      this.poops=[]; this.powers=[];\n      this.score=0; this.best=Storage.getBest();\n      this.spawnTimer=0; this.spawnInterval=0.9; this.level=1; // kept for compatibility\n      this.alive=false; this.paused=false; this.slowmo=0; this.playerName = Storage.getName();\n      this.input={left:false,right:false,dragX:null};\n      this.last=now(); this.onFrame=this.onFrame.bind(this);\n      this.bindInput(); this.bindVisibility(); this.updateHUD();\n      renderBoard(document.getElementById('leaderboard-list'), Storage.getBoard());\n      const nameInput = document.getElementById('player-name'); if(nameInput){ nameInput.value = this.playerName; }\n      this.loadGlobalBoards();\n      // Disable canvas clicks while start screen is visible\n      const startEl = document.getElementById('start-screen');\n      const overEl = document.getElementById('gameover-screen');\n      if(startEl?.classList.contains('visible') || overEl?.classList.contains('visible')) this.c.style.pointerEvents = 'none';\n    }\n\n    async loadGlobalBoards(){\n      const data = await fetchGlobalTop10();\n      renderBoard(document.getElementById('leaderboard-global'), data);\n      renderBoard(document.getElementById('leaderboard-global-final'), data);\n    }\n\n    bindInput(){\n      window.addEventListener('keydown',e=>{ if(e.key==='ArrowLeft'||e.key==='a'||e.key==='A') this.input.left=true; if(e.key==='ArrowRight'||e.key==='d'||e.key==='D') this.input.right=true; if(e.key==='p'||e.key==='P') this.togglePause(); });\n      window.addEventListener('keyup',e=>{ if(e.key==='ArrowLeft'||e.key==='a'||e.key==='A') this.input.left=false; if(e.key==='ArrowRight'||e.key==='d'||e.key==='D') this.input.right=false; });\n      const left=document.getElementById('btn-left'); const right=document.getElementById('btn-right');\n      const set=(b,v)=>{ if(!b) return; b.onpointerdown=()=>{ this.input[v]=true; Audio.ensure(); }; b.onpointerup=b.onpointercancel=()=>this.input[v]=false; };\n      set(left,'left'); set(right,'right');\n      this.c.addEventListener('pointerdown',e=>{ this.input.dragX=e.clientX; Audio.ensure(); Audio.resume(); });\n      window.addEventListener('pointermove',e=>{ if(this.input.dragX!=null){ const dx=e.clientX-this.input.dragX; this.player.x=clamp(this.player.x+dx*0.8, 0, this.w-this.player.w); this.input.dragX=e.clientX; }});\n      window.addEventListener('pointerup',()=>{ this.input.dragX=null; });\n\n      const startBtn = document.getElementById('btn-start');\n      const restartBtn = document.getElementById('btn-restart');\n      const pauseBtn = document.getElementById('btn-pause');\n      const resumeBtn = document.getElementById('btn-resume');\n      const soundBtn = document.getElementById('btn-sound');\n      const nameInput = document.getElementById('player-name');\n\n      const doStart = ()=>{\n        const name = sanitizeName(nameInput?.value||'');\n        if(!name){ nameInput?.focus(); nameInput?.classList.add('error'); setTimeout(()=>nameInput?.classList.remove('error'), 600); return; }\n        this.playerName = name; Storage.setName(name);\n        this.start();\n      };\n      if(startBtn) startBtn.onclick=doStart;\n      if(restartBtn) restartBtn.onclick=doStart;\n      if(pauseBtn) pauseBtn.onclick=()=>this.togglePause();\n      if(resumeBtn) resumeBtn.onclick=()=>this.togglePause(false);\n      if(soundBtn) soundBtn.onclick=()=>{ const on=Audio.toggle(); soundBtn.textContent=on?'üîä':'üîá'; };\n    }\n\n    bindVisibility(){ document.addEventListener('visibilitychange',()=>{ if(document.hidden) this.setPause(true); }); }\n    setPause(v){ this.paused=v; document.getElementById('pause-screen')?.classList.toggle('visible', this.alive && this.paused); }\n    togglePause(force){ if(!this.alive) return; this.setPause(force==null? !this.paused : !!force); }\n    updateHUD(){ document.getElementById('score').textContent=this.score|0; document.getElementById('best').textContent=this.best|0; }\n\n    start(){\n      this.reset(); this.alive=true;\n      document.getElementById('start-screen')?.classList.remove('visible');\n      document.getElementById('gameover-screen')?.classList.remove('visible');\n      // Re-enable canvas input once overlays are hidden\n      this.c.style.pointerEvents = 'auto';\n      requestAnimationFrame(this.onFrame);\n    }\n\n    async gameover(){\n      this.alive=false;\n      document.getElementById('final-score').textContent=this.score|0;\n      if(this.score>this.best){ this.best=this.score; Storage.setBest(this.best); this.updateHUD(); }\n      const result = submitScore(this.playerName||'Player', this.score|0);\n      const rankLine = document.getElementById('rank-line');\n      rankLine.textContent = result.rank? `${this.playerName}Îãò Îû≠ÌÇπ ${result.rank}ÏúÑ!` : `${this.playerName}ÎãòÏùò Ï†êÏàòÍ∞Ä Í∏∞Î°ùÎêòÏóàÏäµÎãàÎã§.`;\n      renderBoard(document.getElementById('leaderboard-list-final'), result.board);\n      renderBoard(document.getElementById('leaderboard-list'), result.board);\n      await submitGlobalScore(this.playerName||'Player', this.score|0);\n      await this.loadGlobalBoards();\n      document.getElementById('gameover-screen')?.classList.add('visible');\n      // Disable canvas while gameover overlay is visible\n      this.c.style.pointerEvents = 'none';\n    }\n\n    reset(){\n      this.score=0; this.level=1; this.spawnInterval=0.9; this.spawnTimer=0; this.slowmo=0;\n      this.player.x=this.w/2-17; this.player.y=this.h-56; this.player.shield=0;\n      for(const p of this.poops) this.poopPool.put(p); this.poops.length=0;\n      for(const p of this.powers) this.powerPool.put(p); this.powers.length=0;\n      this.last=now(); this.paused=false; this.updateHUD();\n    }\n\n    getTier(){ return Math.floor((this.score|0) / 50); }\n    getDifficulty(){\n      const tier = this.getTier();\n      const b = { interval: 0.9, speed: 140, duo: 0.15, power: 0.14 };\n      const r = { interval: 0.86, speed: 1.12, duo: 1.18, power: 0.88 };\n      const c = { intervalMin: 0.12, duoMax: 0.6, powerMin: 0.03 };\n      const interval = Math.max(c.intervalMin, b.interval * Math.pow(r.interval, tier));\n      const speed    = b.speed * Math.pow(r.speed, tier);\n      const duoProb  = Math.min(c.duoMax, b.duo * Math.pow(r.duo, tier));\n      const pwrProb  = Math.max(c.powerMin, b.power * Math.pow(r.power, tier));\n      return { tier, interval, speed, duoProb, pwrProb };\n    }\n\n    spawn(){\n      const d = this.getDifficulty();\n      this.spawnInterval = d.interval;\n      const count = Math.random() < d.duoProb ? 2 : 1;\n      for(let i=0;i<count;i++){\n        const p=this.poopPool.get();\n        p.spawn(rand(0,this.w-24), -rand(24,140), d.speed*rand(0.9,1.25));\n        this.poops.push(p);\n      }\n      if(Math.random() < d.pwrProb){\n        const t=Math.random()<0.6?'shield':'slow';\n        const pu=this.powerPool.get();\n        pu.spawn(rand(0,this.w-20), -40, t);\n        this.powers.push(pu);\n      }\n      if(d.tier> (this.lastTier||0)){ this.lastTier=d.tier; Audio.beep(880,0.06,'triangle',0.12); }\n    }\n\n    step(dt){\n      const move=(this.input.left?-1:0)+(this.input.right?1:0);\n      const speedMod =